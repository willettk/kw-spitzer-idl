pro spec2puflux_arch, fname, ps = ps, nostop = nostop, write = write, nocal = nocal
;+
; NAME:
;       SPEC2PUFLUX_ARCH
;
; PURPOSE:
; 	Read in a trimmed, extracted spectrum along with the measured peakup flux
;	and calibrate spectrum to match PU
;
; INPUTS:
;
; KEYWORDS:
;
;	PS - hard copies of overlaid raw and calibrated spectra
;
;	NOCAL - runs routine without calibration to add suffixes and read artificial fluxes in SMART
;
; EXAMPLE:
;	IDL> spec2puflux_arch, 'arch001'
;
; REQUIRES:
;
;	TAG.pro
;	TARGETS.pro
;	READCOL,pro
;
; NOTES:
;
;	Some of the spectra have offset peakups, meaning that the peakup was performed on the
;	target _itself_. Position peakups mean that a peakup was performed on a nearby object 
;	(2MASS stars, usually) because the science target was too bright or too faint, and so 
;	the object in the peakup files cannot be used for calibration. In either case, the lo-res
;	spectra will be stitched to the LL1 module - if a peakup on the target was performed, then
;	verify that the fluxes match to within 10-15% before performing the stitching.
;
; REVISION HISTORY
;       Written by K. Willett                Nov 2007
;-

; Set device to read in colors

device, decomposed = 0

	yellow = fsc_color('Yellow')
	green = fsc_color('Green')
	red = fsc_color('Red')
	blue = fsc_color('Blue')
	orange = fsc_color('Orange')

; Find directory and object name

tag, fname, dirtag 
targets, fname, redshift, obj

; Read in the spectrum

	specpath = '~/Astronomy/Research/Spitzer/'+dirtag+'/data/idl_spectra/coadd/'

	; Lores

	readcol, specpath+fname+'_sl1_coadd.tbl', $
		det_sl1, wave_sl1, flux_sl1, err_sl1, bit_sl1, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_sl2_coadd.tbl', $
		det_sl2, wave_sl2, flux_sl2, err_sl2, bit_sl2, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_sl3_coadd.tbl', $
		det_sl3, wave_sl3, flux_sl3, err_sl3, bit_sl3, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_ll1_coadd.tbl', $
		det_ll1, wave_ll1, flux_ll1, err_ll1, bit_ll1, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_ll2_coadd.tbl', $
		det_ll2, wave_ll2, flux_ll2, err_ll2, bit_ll2, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_ll3_coadd.tbl', $
		det_ll3, wave_ll3, flux_ll3, err_ll3, bit_ll3, format = 'i,f,f,f,i', skipline = 1, /silent

	; Hires

	readcol, specpath+fname+'_sh_coadd.tbl', $
		det_sh, wave_sh, flux_sh, err_sh, bit_sh, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_lh_coadd.tbl', $
		det_lh, wave_lh, flux_lh, err_lh, bit_lh, format = 'i,f,f,f,i', skipline = 1, /silent

; Read in the filters

pupath = '~/Astronomy/Research/Spitzer/spitzer/'

readcol, pupath+'bluePUtrans.txt', bwave, btrans, /silent
readcol, pupath+'redPUtrans.txt', rwave, rtrans, /silent

if not keyword_set(nocal) then begin

; Read in the artificial flux generated by SMART photometry for each filter

apupath = '~/Astronomy/Research/Spitzer/archived/'

readcol, apupath+'artpu_arch.txt', atag, apu_red_lo, apu_blue_lo, apu_red_hi, apu_blue_hi, $
	format = 'a,f,f,f,f', skipline = 4, /silent

; Restore the Spitzer PU fluxes from the IDL .sav file

restore, '~/Astronomy/Research/Spitzer/archived/data/idl_sav/pu_fluxes.sav'
if n_elements(archfiles) ne n_elements(atag) then begin
	print,'Artificial PU list does not match IRS peakups'
	stop
endif

; Change units from mJy to Jy

pu_fluxes = pu_fluxes * 1d-3

; Locate spectrum of choice

tempind = where(fname eq atag)
if (tempind lt 0 or n_elements(tempind) ne 1) then print, 'Did not find fluxes'
tempind = tempind(0)

apu_blue_lo = apu_blue_lo(tempind)
apu_red_lo = apu_red_lo(tempind)
apu_blue_hi = apu_blue_hi(tempind)
apu_red_hi = apu_red_hi(tempind)
pu_fluxes = pu_fluxes(tempind)

; Determine whether the peakup is on the science target or a nearby star

ispupos = pu_type(tempind)
if ispupos eq 0 then print, fname+' is an offset peakup (on science target)' else $
	print, fname+' is a position peakup (using nearby star)'

; Determine which filter the peakup applies to and calibrate

this_filter = pu_filter(tempind)

if this_filter eq 'Red' then begin
	scalefactor = pu_fluxes / apu_red_lo 
endif else if this_filter eq 'Blu' then begin
	scalefactor = pu_fluxes / apu_blue_lo
endif else begin
	print,'Filter not found'
	stop
endelse
if ispupos eq 0 then print,'Measured / artificial PU flux in '+this_filter+': ', string(scalefactor,format='(f5.2)')

; LL1 module (18-35 um) is fixed

calflux_ll1 = flux_ll1

; Anchor LL2 to LL1

	first_pixel = wave_ll1(0)
	last_pixel= wave_ll2(n_elements(wave_ll2)-1)

	if first_pixel gt last_pixel then begin		; If there is no overlap between modules, then align the last few pixels
	
		npix = 2				; Number of pixels used to align modules

		last_sec = flux_ll2(n_elements(flux_ll2)-npix:n_elements(flux_ll2)-1)
		first_sec = calflux_ll1(0:npix-1)

		ll2_ll1_frac = mean(first_sec) / mean(last_sec)	
		
		calflux_ll2 = flux_ll2 * ll2_ll1_frac
	
	endif else begin				; If there is overlap, then move the modules up and down for the best fit
	
		overlap_pixels = where(wave_ll2 ge first_pixel)
		n_overlap = n_elements(overlap_pixels)
		overlap_bin = intarr(n_overlap)
		for i = 0, n_overlap - 1 do begin
			junk1 = where(abs(wave_ll2(overlap_pixels(0)+i) - wave_ll1) eq $
				min(abs(wave_ll2(overlap_pixels(0)+i) - wave_ll1)))
			overlap_bin(i) = fix(junk1(0))
		endfor
		nsteps = 1000
		caltot = fltarr(nsteps)
		for i = 0, nsteps - 1 do begin
			tempcal = flux_ll2(overlap_pixels) * (0.5d + (1. * i / nsteps))
			caltot(i) = abs(total(tempcal - calflux_ll1(overlap_bin)))
		endfor
	
		junkindex = where(caltot eq min(caltot))
		ll2_ll1_frac = (0.5d + (1. * junkindex(0) / nsteps))

		calflux_ll2 = flux_ll2 * ll2_ll1_frac
	endelse

; Anchor SL1 to LL2

	first_pixel = wave_ll2(0)
	last_pixel= wave_sl1(n_elements(wave_sl1)-1)

	if first_pixel gt last_pixel then begin		; If there is no overlap between modules, then align the last few pixels
	
		npix = 2				; Number of pixels used to align modules

		last_sec = flux_sl1(n_elements(flux_sl1)-npix:n_elements(flux_sl1)-1)
		first_sec = calflux_ll2(0:npix-1)

		sl1_ll2_frac = mean(first_sec) / mean(last_sec)	
		
		calflux_sl1 = flux_sl1 * sl1_ll2_frac
	
	endif else begin				; If there is overlap, then move the modules up and down for the best fit
	
		overlap_pixels = where(wave_sl1 ge first_pixel)
		n_overlap = n_elements(overlap_pixels)
		overlap_bin = intarr(n_overlap)
		for i = 0, n_overlap - 1 do begin
			junk2 = where(abs(wave_sl1(overlap_pixels(0)+i) - wave_ll2) eq $
				min(abs(wave_sl1(overlap_pixels(0)+i) - wave_ll2)))
			overlap_bin(i) = fix(junk2(0))
		endfor
		nsteps = 1000
		caltot = fltarr(nsteps)
		for i = 0, nsteps - 1 do begin
			tempcal = flux_sl1(overlap_pixels) * (0.5d + (1. * i / nsteps))
			caltot(i) = abs(total(tempcal - calflux_ll2(overlap_bin)))
		endfor
	
		junkindex = where(caltot eq min(caltot))
		sl1_ll2_frac = (0.5d + (1. * junkindex(0) / nsteps))

		calflux_sl1 = flux_sl1 * sl1_ll2_frac
	endelse

; Anchor SL2 to SL1

	first_pixel = wave_sl1(0)
	last_pixel= wave_sl2(n_elements(wave_sl2)-1)

	if first_pixel gt last_pixel then begin		; If there is no overlap between modules, then align the last few pixels
	
		npix = 2				; Number of pixels used to align modules

		last_sec = flux_sl2(n_elements(flux_sl2)-npix:n_elements(flux_sl2)-1)
		first_sec = calflux_sl1(0:npix-1)

		sl2_sl1_frac = mean(first_sec) / mean(last_sec)	
		
		calflux_sl2 = flux_sl2 * sl2_sl1_frac
	
	endif else begin				; If there is overlap, then move the modules up and down for the best fit
	
		overlap_pixels = where(wave_sl2 ge first_pixel)
		n_overlap = n_elements(overlap_pixels)
		overlap_bin = intarr(n_overlap)
		for i = 0, n_overlap - 1 do begin 
			junk3 = where(abs(wave_sl2(overlap_pixels(0)+i) - wave_sl1) eq $
				min(abs(wave_sl2(overlap_pixels(0)+i) - wave_sl1)))
			overlap_bin(i) = fix(junk3(0))
		endfor
		nsteps = 1000
		caltot = fltarr(nsteps)
		for i = 0, nsteps - 1 do begin
			tempcal = flux_sl2(overlap_pixels) * (0.5d + (1. * i / nsteps))
			caltot(i) = abs(total(tempcal - calflux_sl1(overlap_bin)))
		endfor
	
		junkindex = where(caltot eq min(caltot))
		sl2_sl1_frac = (0.5d + (1. * junkindex(0) / nsteps))

		calflux_sl2 = flux_sl2 * sl2_sl1_frac
	endelse

; Calibrate bonus orders to first-order modules

calflux_sl3 = flux_sl3 * sl1_ll2_frac
calflux_ll3 = flux_ll3


; Match the LH and SH spectra

restore, '~/Astronomy/Research/Spitzer/archived/data/idl_sav/arch_lhsky.sav'
skyind = where(fname eq archfiles)
isthere_lhsky = isthere_lhsky(skyind)

; Align the HR modules

	first_pixel = wave_lh(0)
	last_pixel= wave_sh(n_elements(wave_sh)-1)

	if first_pixel gt last_pixel then begin		; If there is no overlap between modules, then align the last few pixels
	
		npix = 2				; Number of pixels used to align modules

		last_sec = flux_sh(n_elements(flux_sh)-npix:n_elements(flux_sh)-1)
		first_sec = flux_lh(0:npix-1)

		hr_frac = mean(first_sec) / mean(last_sec)	
		
		if isthere_lhsky eq 0 then begin
			calflux_lh = flux_lh / hr_frac 
			calflux_sh = flux_sh
		endif else begin
			calflux_sh = flux_sh * hr_frac
			calflux_lh = flux_lh
		endelse
	
	endif else begin				; If there is overlap, then move the modules up and down for the best fit
	
		overlap_pixels = where(wave_sh ge first_pixel)
		n_overlap = n_elements(overlap_pixels)
		overlap_bin = intarr(n_overlap)
		for i = 0, n_overlap - 1 do begin
			junk4 = where(abs(wave_sh(overlap_pixels(0)+i) - wave_lh) eq $
				min(abs(wave_sh(overlap_pixels(0)+i) - wave_lh)))
			overlap_bin(i) = fix(junk4(0))
		endfor
		nsteps = 1000
		caltot = fltarr(nsteps)
		for i = 0, nsteps - 1 do begin
			tempcal = flux_sh(overlap_pixels) * (0.5d + (1. * i / nsteps))
			caltot(i) = abs(total(tempcal - flux_lh(overlap_bin)))
		endfor
	
		junkindex = where(caltot eq min(caltot))
		hr_frac = (0.5d + (1. * junkindex(0) / nsteps))

		if isthere_lhsky eq 0 then begin
			calflux_lh = flux_lh / hr_frac 
			calflux_sh = flux_sh
		endif else begin
			calflux_sh = flux_sh * hr_frac
			calflux_lh = flux_lh
		endelse

	endelse


; Compare scale factors

print,''
print, 'Running ',fname
;print, 'Scaling to low-res: ', scalemin_long
;print, 'Scaling to red PU:  ', my_redpu / apu_red_hi

!p.multi = [0,1,2]

; LORES spectra

pspath = '~/Astronomy/Research/Spitzer/'+dirtag+'/plots/calibration/'

if keyword_set(ps) then begin
	set_plot,'ps'
	device, filename = pspath+fname+'_calflux.ps', /landscape, /color, bits_per_pixel = 8
	axiscolor = fsc_color('Black')
	bgcolor = fsc_color('White')
	cs = 1
	ct = 2
endif else begin
	axiscolor = fsc_color('White')
	bgcolor = fsc_color('Black')
	cs = 2
	ct = 1
endelse

plot, wave_sl1, flux_sl1, $
	xtitle = 'Wavelength [!7l!3m]', $
	ytitle = 'Flux [Jy]', $
	xr = [4,40], /xstyle, $
	yr = [1d-4,1d1], /ystyle, $
	/xlog,/ylog, $
	title = obj, $
	charsize = cs, $
	color = axiscolor, $
	background = bgcolor, $
	linestyle = 2, $
	thick = ct, $
	charthick = ct, $
	/nodata


oplot, wave_sl1, flux_sl1, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_sl2, flux_sl2, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_sl3, flux_sl3, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_ll1, flux_ll1, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_ll2, flux_ll2, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_ll3, flux_ll3, color = axiscolor, linestyle = 2, thick = ct

oplot, wave_ll2, calflux_ll2, color = blue, thick = ct
oplot, wave_ll3, calflux_ll3, color = orange, thick = ct
oplot, wave_ll1, calflux_ll1, color = red, thick = ct
oplot, wave_sl2, calflux_sl2, color = yellow, thick = ct
oplot, wave_sl3, calflux_sl3, color = orange, thick = ct
oplot, wave_sl1, calflux_sl1, color = green, thick = ct

oplot, rwave, rtrans / max(rtrans) * max(flux_ll1), linestyle = 1, color=red, thick = ct
oplot, bwave, btrans / max(btrans) * max(flux_ll1), linestyle = 1, color=blue, thick = ct


oplot, [16], [apu_blue_lo],  psym = 4, color = axiscolor,  symsize = 2
oplot, [22], [apu_red_lo],   psym = 4, color = axiscolor,  symsize = 2
if this_filter eq 'Blu' then oplot, [16], [pu_fluxes], psym = 4, color = blue, symsize = 2 else $
	oplot, [22], [pu_fluxes],  psym = 4, color = red,  symsize = 2

xyouts, 0.2, 0.85, 'Lo-res', /normal, charsize = cs, charthick = ct, color = axiscolor

; HIRES spectra

plot, wave_sh, flux_sh, $
	xtitle = 'Wavelength [!7l!3m]', $
	ytitle = 'Flux [Jy]', $
	xr = [5,40], $
	yr = [0,max(flux_lh)], $
	title = obj, $
	charsize = cs, $
	linestyle = 2, $
	color = axiscolor, $
	background = bgcolor, $
	thick = ct, $
	charthick = ct, $
	/nodata

oplot, wave_sh, flux_sh, color = axiscolor, linestyle = 1, thick = ct, psym = 10
oplot, wave_lh, flux_lh, color = axiscolor, linestyle = 1, thick = ct, psym = 10
oplot, wave_sh, calflux_sh, color = blue, linestyle = 0, thick = ct, psym = 10
oplot, wave_lh, calflux_lh, color = red, linestyle = 0, thick = ct, psym = 10

oplot, rwave, rtrans / max(rtrans) * max(flux_lh), linestyle = 1, color=red, thick = ct
oplot, bwave, btrans / max(btrans) * max(flux_lh), linestyle = 1, color=blue, thick = ct

if this_filter eq 'Blu' then oplot, [16], [pu_fluxes], psym = 4, color = blue, symsize = 2 else $
	oplot, [22], [pu_fluxes],  psym = 4, color = red,  symsize = 2

xyouts, 0.2, 0.35, 'Hi-res', /normal, charsize = cs, charthick = ct, color = axiscolor
xyouts, 0.9, 0.95, fname, /normal, charsize = cs, charthick = ct, color=axiscolor

if keyword_set(ps) then begin
	device, /close
	set_plot,'x'
endif

endif		; NOCAL

; Open the individual nods and calibrate them using the same scale factors as the coadded spectra

nodpath = '~/Astronomy/Research/Spitzer/'+dirtag+'/data/idl_spectra/nods/'

	; Lores

	readcol, nodpath+fname+'_sl1_1p.tbl', $
		det_sl1_1p, wave_sl1_1p, flux_sl1_1p, err_sl1_1p, bit_sl1_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl1_2p.tbl', $
		det_sl1_2p, wave_sl1_2p, flux_sl1_2p, err_sl1_2p, bit_sl1_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl2_1p.tbl', $
		det_sl2_1p, wave_sl2_1p, flux_sl2_1p, err_sl2_1p, bit_sl2_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl2_2p.tbl', $
		det_sl2_2p, wave_sl2_2p, flux_sl2_2p, err_sl2_2p, bit_sl2_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl3_1p.tbl', $
		det_sl3_1p, wave_sl3_1p, flux_sl3_1p, err_sl3_1p, bit_sl3_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl3_2p.tbl', $
		det_sl3_2p, wave_sl3_2p, flux_sl3_2p, err_sl3_2p, bit_sl3_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll1_1p.tbl', $
		det_ll1_1p, wave_ll1_1p, flux_ll1_1p, err_ll1_1p, bit_ll1_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll1_2p.tbl', $
		det_ll1_2p, wave_ll1_2p, flux_ll1_2p, err_ll1_2p, bit_ll1_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll2_1p.tbl', $
		det_ll2_1p, wave_ll2_1p, flux_ll2_1p, err_ll2_1p, bit_ll2_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll2_2p.tbl', $
		det_ll2_2p, wave_ll2_2p, flux_ll2_2p, err_ll2_2p, bit_ll2_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll3_1p.tbl', $
		det_ll3_1p, wave_ll3_1p, flux_ll3_1p, err_ll3_1p, bit_ll3_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll3_2p.tbl', $
		det_ll3_2p, wave_ll3_2p, flux_ll3_2p, err_ll3_2p, bit_ll3_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	; Hires

	readcol, nodpath+fname+'_sh_1p.tbl', $
		det_sh_1p, wave_sh_1p, flux_sh_1p, err_sh_1p, bit_sh_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sh_2p.tbl', $
		det_sh_2p, wave_sh_2p, flux_sh_2p, err_sh_2p, bit_sh_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_lh_1p.tbl', $
		det_lh_1p, wave_lh_1p, flux_lh_1p, err_lh_1p, bit_lh_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_lh_2p.tbl', $
		det_lh_2p, wave_lh_2p, flux_lh_2p, err_lh_2p, bit_lh_2p, format = 'i,f,f,f,i', skipline = 1, /silent

if not keyword_set(nocal) then begin

; Calibrate the nods to peakups

; Lo-res

	calflux_sl1_1p = flux_sl1_1p * sl1_ll2_frac
	calflux_sl2_1p = flux_sl2_1p * sl2_sl1_frac
	calflux_sl3_1p = flux_sl3_1p * sl1_ll2_frac
	calflux_ll1_1p = flux_ll1_1p
	calflux_ll3_1p = flux_ll3_1p 
	calflux_ll2_1p = flux_ll2_1p * ll2_ll1_frac
	
	calflux_sl1_2p = flux_sl1_2p * sl1_ll2_frac
	calflux_sl2_2p = flux_sl2_2p * sl2_sl1_frac
	calflux_sl3_2p = flux_ll1_2p * sl1_ll2_frac
	calflux_ll1_2p = flux_ll1_2p 
	calflux_ll3_2p = flux_ll3_2p 
	calflux_ll2_2p = flux_ll2_2p * ll2_ll1_frac
	
; Hi-res

calflux_sh_1p = flux_sh_1p
calflux_lh_1p = flux_lh_1p

calflux_sh_2p = flux_sh_2p
calflux_lh_2p = flux_lh_2p

; Option for non-calibrated spectra (or when PUs are suspect)

endif

if keyword_set(nocal) then begin

	calflux_sl1 = flux_sl1
	calflux_sl2 = flux_sl2
	calflux_sl3 = flux_sl3
	calflux_ll1 = flux_ll1
	calflux_ll2 = flux_ll2
	calflux_ll3 = flux_ll3
	calflux_sh  = flux_sh
	calflux_lh  = flux_lh
	
	calflux_sl1_1p = flux_sl1_1p
	calflux_sl2_1p = flux_sl2_1p
	calflux_sl3_1p = flux_sl3_1p
	calflux_ll1_1p = flux_ll1_1p
	calflux_ll2_1p = flux_ll2_1p
	calflux_ll3_1p = flux_ll3_1p
	calflux_sh_1p  = flux_sh_1p
	calflux_lh_1p  = flux_lh_1p
	
	calflux_sl1_2p = flux_sl1_2p
	calflux_sl2_2p = flux_sl2_2p
	calflux_sl3_2p = flux_sl3_2p
	calflux_ll1_2p = flux_ll1_2p
	calflux_ll2_2p = flux_ll2_2p
	calflux_ll3_2p = flux_ll3_2p
	calflux_sh_2p  = flux_sh_2p
	calflux_lh_2p  = flux_lh_2p

endif

if keyword_set(write) then begin

	; Writing calibrated spectra to disk
	
	writepath_coadd = '~/Astronomy/Research/Spitzer/'+dirtag+'/data/idl_spectra/calibrated/coadd/'
	writepath_nod   = '~/Astronomy/Research/Spitzer/'+dirtag+'/data/idl_spectra/calibrated/nods/'

	; Coadded

	forprint, det_sl1, wave_sl1, calflux_sl1, err_sl1, bit_sl1, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_sl1_cal.tbl', /silent

	forprint, det_sl2, wave_sl2, calflux_sl2, err_sl2, bit_sl2, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_sl2_cal.tbl', /silent

	forprint, det_sl3, wave_sl3, calflux_sl3, err_sl3, bit_sl3, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_sl3_cal.tbl', /silent

	forprint, det_ll1, wave_ll1, calflux_ll1, err_ll1, bit_ll1, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_ll1_cal.tbl', /silent

	forprint, det_ll2, wave_ll2, calflux_ll2, err_ll2, bit_ll2, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_ll2_cal.tbl', /silent

	forprint, det_ll3, wave_ll3, calflux_ll3, err_ll3, bit_ll3, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_ll3_cal.tbl', /silent

	forprint, det_sh, wave_sh, calflux_sh, err_sh, bit_sh, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_sh_cal.tbl', /silent

	forprint, det_lh, wave_lh, calflux_lh, err_lh, bit_lh, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_lh_cal.tbl', /silent

	; Nods

	forprint, det_sl1_1p, wave_sl1_1p, calflux_sl1_1p, err_sl1_1p, bit_sl1_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl1_1p_cal.tbl', /silent

	forprint, det_sl1_1p, wave_sl1_1p, calflux_sl1_1p, err_sl1_1p, bit_sl1_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl1_2p_cal.tbl', /silent

	forprint, det_sl2_1p, wave_sl2_1p, calflux_sl2_1p, err_sl2_1p, bit_sl2_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl2_1p_cal.tbl', /silent

	forprint, det_sl2_2p, wave_sl2_2p, calflux_sl2_2p, err_sl2_2p, bit_sl2_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl2_2p_cal.tbl', /silent

	forprint, det_sl3_1p, wave_sl3_1p, calflux_sl3_1p, err_sl3_1p, bit_sl3_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl3_1p_cal.tbl', /silent

	forprint, det_sl3_2p, wave_sl3_2p, calflux_sl3_2p, err_sl3_2p, bit_sl3_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl3_2p_cal.tbl', /silent

	forprint, det_ll1_1p, wave_ll1_1p, calflux_ll1_1p, err_ll1_1p, bit_ll1_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll1_1p_cal.tbl', /silent

	forprint, det_ll1_2p, wave_ll1_2p, calflux_ll1_2p, err_ll1_2p, bit_ll1_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll1_2p_cal.tbl', /silent

	forprint, det_ll2_1p, wave_ll2_1p, calflux_ll2_1p, err_ll2_1p, bit_ll2_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll2_1p_cal.tbl', /silent

	forprint, det_ll2_2p, wave_ll2_2p, calflux_ll2_2p, err_ll2_2p, bit_ll2_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll2_2p_cal.tbl', /silent

	forprint, det_ll3_1p, wave_ll3_1p, calflux_ll3_1p, err_ll3_1p, bit_ll3_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll3_1p_cal.tbl', /silent

	forprint, det_ll3_2p, wave_ll3_2p, calflux_ll3_2p, err_ll3_2p, bit_ll3_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll3_2p_cal.tbl', /silent

	forprint, det_sh_1p, wave_sh_1p, calflux_sh_1p, err_sh_1p, bit_sh_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sh_1p_cal.tbl', /silent

	forprint, det_sh_2p, wave_sh_2p, calflux_sh_2p, err_sh_2p, bit_sh_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sh_2p_cal.tbl', /silent

	forprint, det_lh_1p, wave_lh_1p, calflux_lh_1p, err_lh_1p, bit_lh_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_lh_1p_cal.tbl', /silent

	forprint, det_lh_2p, wave_lh_2p, calflux_lh_2p, err_lh_2p, bit_lh_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_lh_2p_cal.tbl', /silent

endif

print, 'LL2 to LL1 scale factor: ', ll2_ll1_frac
print, 'SL1 to LL2 scale factor: ', sl1_ll2_frac
print, 'SL2 to SL1 scale factor: ', sl2_sl1_frac
print, 'Calibrated spectra to peakup fluxes for ',fname

if not keyword_set(nostop) then stop
end

