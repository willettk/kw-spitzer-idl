pro spec2puflux_lr, fname, ps = ps, nostop = nostop, write = write, nocal = nocal
;+
; NAME:
;       SPEC2PUFLUX_LR
;
; PURPOSE:
; 	Read in a trimmed, extracted spectrum along with the measured peakup flux
;	and calibrate spectrum to match PU
;
; INPUTS:
;
;	artificial_pu.csv - 	Excel spreadsheet containing measured artificial peakup
;				fluxes and true values for entire sample. 
;
; OUTPUTS:
;
; KEYWORDS:
;
;	PS - hard copies of overlaid raw and calibrated spectra
;
;	NOSTOP - program does not stop after executing
;
;	WRITE - write out calibrated spectrum as ASCII file
;
;	NOCAL - do not calibrate to peakups (used to add the _cal suffix, as used by batch files)
;
; EXAMPLE:
;	IDL> spec2puflux_lr, /ps
;
; REQUIRES:
;
;	TAG.pro
;	TARGETS.pro
;	READCOL,pro
;
; NOTES:
;
; REVISION HISTORY
;       Written by K. Willett                Jul 2007
; 	Major revisions - KW, Aug 2007
; 	Default if no PU data exists (control sample) is to leave the spectra unscaled - KW, Aug 27 07
;-

; Set device to read in colors

device, decomposed = 0

	yellow = fsc_color('Yellow')
	green = fsc_color('Green')
	red = fsc_color('Red')
	blue = fsc_color('Blue')
	orange = fsc_color('Orange')

; Find directory and object name

tag, fname, dirtag 
targets, fname, redshift, obj

; Read in the spectrum

	specpath = '~/Astronomy/Research/Spitzer/'+dirtag+'/data/idl_spectra/coadd/'

	; Lores

	readcol, specpath+fname+'_sl1_coadd.tbl', $
		det_sl1, wave_sl1, flux_sl1, err_sl1, bit_sl1, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_sl2_coadd.tbl', $
		det_sl2, wave_sl2, flux_sl2, err_sl2, bit_sl2, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_sl3_coadd.tbl', $
		det_sl3, wave_sl3, flux_sl3, err_sl3, bit_sl3, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_ll1_coadd.tbl', $
		det_ll1, wave_ll1, flux_ll1, err_ll1, bit_ll1, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_ll2_coadd.tbl', $
		det_ll2, wave_ll2, flux_ll2, err_ll2, bit_ll2, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, specpath+fname+'_ll3_coadd.tbl', $
		det_ll3, wave_ll3, flux_ll3, err_ll3, bit_ll3, format = 'i,f,f,f,i', skipline = 1, /silent

; Read in the filters

pupath = '~/Astronomy/Research/Spitzer/spitzer/'

readcol, pupath+'bluePUtrans.txt', bwave, btrans, /silent
readcol, pupath+'redPUtrans.txt', rwave, rtrans, /silent

; Read in the artificial flux generated by SMART photometry for each filter

apupath = '~/Astronomy/Research/Spitzer/'

readcol, apupath+'artificial_pu.csv', atag, aobj, apu_blue_lo, apu_red_lo, apu_blue_hi, apu_red_hi, my_bluepu, my_redpu, $
	format = 'a,a,a,a,a,a,a,a', skipline = 3,/silent

; Change units from mJy to Jy

apu_blue_lo(where(apu_blue_lo eq 'nodata')) = 0. & apu_blue_lo = float(apu_blue_lo)
apu_red_lo(where(apu_red_lo eq 'nodata')) = 0. & apu_red_lo = float(apu_red_lo)
my_bluepu(where(my_bluepu eq 'nodata')) = 0. & my_bluepu = float(my_bluepu)
my_redpu(where(my_redpu eq 'nodata')) = 0. & my_redpu = float(my_redpu)

apu_blue_lo = apu_blue_lo * 1d-3
apu_red_lo = apu_red_lo * 1d-3
my_bluepu = my_bluepu * 1d-3
my_redpu = my_redpu * 1d-3

; Locate spectrum of choice

tempind = where(fname eq atag)
if (tempind lt 0 or n_elements(tempind) ne 1) then print, 'Did not find fluxes'

apu_blue_lo = apu_blue_lo(tempind(0))
apu_red_lo = apu_red_lo(tempind(0))
my_bluepu = my_bluepu(tempind(0))
my_redpu = my_redpu(tempind(0))

if my_bluepu eq 0. then my_bluepu = apu_blue_lo
if my_redpu eq 0. then my_redpu = apu_red_lo

; Calibrated spectra

calflux_ll1 = flux_ll1 * my_redpu / apu_red_lo
calflux_ll3 = flux_ll3 * my_redpu / apu_red_lo
calflux_ll2 = flux_ll2 * my_bluepu / apu_blue_lo

; Calibrate SL1, SL2 to LL2

; Solution:
; - find the region of pixels that overlap in both orders
; - find each bin in one that corresponds most closely to another
; - match the bins
; - step through different scale heights until residuals are minimized

; - If no overlap exists between the orders, simply match the mean/median of some number of border pixels.

; Check for overlap

lastsl1_pixel = wave_sl1(n_elements(wave_sl1)-1)
firstll2_pixel= wave_ll2(0)

if firstll2_pixel gt lastsl1_pixel then begin

	npix = 2
	last_sl1 = flux_sl1(n_elements(flux_sl1)-npix:n_elements(flux_sl1)-1)
	first_ll2 = calflux_ll2(0:npix-1)
	ll2_sl1_frac = mean(first_ll2) / mean(last_sl1)
	
	calflux_sl1 = ll2_sl1_frac * flux_sl1
	calflux_sl2 = ll2_sl1_frac * flux_sl2
	calflux_sl3 = ll2_sl1_frac * flux_sl3

endif else begin

	overlap_pixels = where(wave_sl1 ge firstll2_pixel)
	n_overlap = n_elements(overlap_pixels)
	overlap_bin = intarr(n_overlap)
	for i = 0, n_overlap - 1 do $
		overlap_bin(i) = where(abs(wave_sl1(overlap_pixels(0)+i) - wave_ll2) eq min(abs(wave_sl1(overlap_pixels(0)+i) - wave_ll2)))
	nsteps = 1000
	caltot = fltarr(nsteps)
	for i = 0, nsteps - 1 do begin
		tempcal = flux_sl1(overlap_pixels) * (0.5d + (1. * i / nsteps))
		caltot(i) = abs(total(tempcal - calflux_ll2(overlap_bin)))
	endfor

	junkindex = where(caltot eq min(caltot))
	ll2_sl1_frac = (0.5d + (1. * junkindex(0) / nsteps))

	calflux_sl1 = ll2_sl1_frac * flux_sl1
	calflux_sl2 = ll2_sl1_frac * flux_sl2
	calflux_sl3 = ll2_sl1_frac * flux_sl3

endelse

!p.multi = [0,1,1]

; LORES spectra

pspath = '~/Astronomy/Research/Spitzer/'+dirtag+'/plots/calibration/'

if keyword_set(ps) then begin
	set_plot,'ps'
	device, filename = pspath+fname+'_calflux.ps', /landscape, /color, bits_per_pixel = 8
	axiscolor = fsc_color('Black')
	bgcolor = fsc_color('White')
	cs = 1
	ct = 2
endif else begin
	axiscolor = fsc_color('White')
	bgcolor = fsc_color('Black')
	cs = 2
	ct = 1
endelse

plot, wave_sl1, flux_sl1, $
	xtitle = 'Wavelength [!7l!3m]', $
	ytitle = 'Flux [Jy]', $
	xr = [4,40], /xstyle, $
	yr = [1d-4,1d1], /ystyle, $
	/xlog,/ylog, $
	title = obj, $
	charsize = cs, $
	color = axiscolor, $
	background = bgcolor, $
	linestyle = 2, $
	thick = ct, $
	charthick = ct, $
	/nodata


oplot, wave_sl1, flux_sl1, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_sl2, flux_sl2, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_sl3, flux_sl3, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_ll1, flux_ll1, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_ll2, flux_ll2, color = axiscolor, linestyle = 2, thick = ct
oplot, wave_ll3, flux_ll3, color = axiscolor, linestyle = 2, thick = ct

oplot, wave_ll2, calflux_ll2, color = blue, thick = ct
oplot, wave_ll3, calflux_ll3, color = orange, thick = ct
oplot, wave_ll1, calflux_ll1, color = red, thick = ct
oplot, wave_sl2, calflux_sl2, color = yellow, thick = ct
oplot, wave_sl3, calflux_sl3, color = orange, thick = ct
oplot, wave_sl1, calflux_sl1, color = yellow, thick = ct

oplot, rwave, rtrans / max(rtrans) * max(flux_ll1), linestyle = 1, color=red, thick = ct
oplot, bwave, btrans / max(btrans) * max(flux_ll1), linestyle = 1, color=blue, thick = ct


oplot, [16], [apu_blue_lo],  psym = 4, color = axiscolor,  symsize = 2
oplot, [22], [apu_red_lo],   psym = 4, color = axiscolor,  symsize = 2
oplot, [16], [my_bluepu], psym = 4, color = blue, symsize = 2
oplot, [22], [my_redpu],  psym = 4, color = red,  symsize = 2

xyouts, 0.2, 0.85, 'Lo-res', /normal, charsize = cs, charthick = ct, color = axiscolor

if keyword_set(ps) then begin
	device, /close
	set_plot,'x'
endif


; Open the individual nods and calibrate them using the same scale factors as the coadded spectra

nodpath = '~/Astronomy/Research/Spitzer/'+dirtag+'/data/idl_spectra/nods/'

	; Lores

	readcol, nodpath+fname+'_sl1_1p.tbl', $
		det_sl1_1p, wave_sl1_1p, flux_sl1_1p, err_sl1_1p, bit_sl1_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl1_2p.tbl', $
		det_sl1_2p, wave_sl1_2p, flux_sl1_2p, err_sl1_2p, bit_sl1_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl2_1p.tbl', $
		det_sl2_1p, wave_sl2_1p, flux_sl2_1p, err_sl2_1p, bit_sl2_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl2_2p.tbl', $
		det_sl2_2p, wave_sl2_2p, flux_sl2_2p, err_sl2_2p, bit_sl2_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl3_1p.tbl', $
		det_sl3_1p, wave_sl3_1p, flux_sl3_1p, err_sl3_1p, bit_sl3_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_sl3_2p.tbl', $
		det_sl3_2p, wave_sl3_2p, flux_sl3_2p, err_sl3_2p, bit_sl3_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll1_1p.tbl', $
		det_ll1_1p, wave_ll1_1p, flux_ll1_1p, err_ll1_1p, bit_ll1_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll1_2p.tbl', $
		det_ll1_2p, wave_ll1_2p, flux_ll1_2p, err_ll1_2p, bit_ll1_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll2_1p.tbl', $
		det_ll2_1p, wave_ll2_1p, flux_ll2_1p, err_ll2_1p, bit_ll2_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll2_2p.tbl', $
		det_ll2_2p, wave_ll2_2p, flux_ll2_2p, err_ll2_2p, bit_ll2_2p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll3_1p.tbl', $
		det_ll3_1p, wave_ll3_1p, flux_ll3_1p, err_ll3_1p, bit_ll3_1p, format = 'i,f,f,f,i', skipline = 1, /silent

	readcol, nodpath+fname+'_ll3_2p.tbl', $
		det_ll3_2p, wave_ll3_2p, flux_ll3_2p, err_ll3_2p, bit_ll3_2p, format = 'i,f,f,f,i', skipline = 1, /silent


; Calibrate to peakups

; Lo-res

calflux_sl1_1p = ll2_sl1_frac * flux_sl1_1p
calflux_sl2_1p = ll2_sl1_frac * flux_sl2_1p
calflux_sl3_1p = ll2_sl1_frac * flux_sl3_1p
calflux_ll1_1p = flux_ll1_1p * my_redpu / apu_red_lo
calflux_ll3_1p = flux_ll3_1p * my_redpu / apu_red_lo
calflux_ll2_1p = flux_ll2_1p * my_bluepu / apu_blue_lo

calflux_sl1_2p = ll2_sl1_frac * flux_sl1_2p
calflux_sl2_2p = ll2_sl1_frac * flux_sl2_2p
calflux_sl3_2p = ll2_sl1_frac * flux_sl3_2p
calflux_ll1_2p = flux_ll1_2p * my_redpu / apu_red_lo
calflux_ll3_2p = flux_ll3_2p * my_redpu / apu_red_lo
calflux_ll2_2p = flux_ll2_2p * my_bluepu / apu_blue_lo

; Option for non-calibrated spectra (for when PUs are suspect)

if keyword_set(nocal) then begin

	calflux_sl1 = flux_sl1
	calflux_sl2 = flux_sl2
	calflux_sl3 = flux_sl3
	calflux_ll1 = flux_ll1
	calflux_ll2 = flux_ll2
	calflux_ll3 = flux_ll3
	
	calflux_sl1_1p = flux_sl1_1p
	calflux_sl2_1p = flux_sl2_1p
	calflux_sl3_1p = flux_sl3_1p
	calflux_ll1_1p = flux_ll1_1p
	calflux_ll2_1p = flux_ll2_1p
	calflux_ll3_1p = flux_ll3_1p
	
	calflux_sl1_2p = flux_sl1_2p
	calflux_sl2_2p = flux_sl2_2p
	calflux_sl3_2p = flux_sl3_2p
	calflux_ll1_2p = flux_ll1_2p
	calflux_ll2_2p = flux_ll2_2p
	calflux_ll3_2p = flux_ll3_2p

endif

if keyword_set(write) then begin

	; Writing calibrated spectra to disk
	
	writepath_coadd = '~/Astronomy/Research/Spitzer/'+dirtag+'/data/idl_spectra/calibrated/coadd/'
	writepath_nod   = '~/Astronomy/Research/Spitzer/'+dirtag+'/data/idl_spectra/calibrated/nods/'

	; Coadded

	forprint, det_sl1, wave_sl1, calflux_sl1, err_sl1, bit_sl1, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_sl1_cal.tbl', /silent

	forprint, det_sl2, wave_sl2, calflux_sl2, err_sl2, bit_sl2, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_sl2_cal.tbl', /silent

	forprint, det_sl3, wave_sl3, calflux_sl3, err_sl3, bit_sl3, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_sl3_cal.tbl', /silent

	forprint, det_ll1, wave_ll1, calflux_ll1, err_ll1, bit_ll1, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_ll1_cal.tbl', /silent

	forprint, det_ll2, wave_ll2, calflux_ll2, err_ll2, bit_ll2, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_ll2_cal.tbl', /silent

	forprint, det_ll3, wave_ll3, calflux_ll3, err_ll3, bit_ll3, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_coadd+fname+'_ll3_cal.tbl', /silent

	; Nods

	forprint, det_sl1_1p, wave_sl1_1p, calflux_sl1_1p, err_sl1_1p, bit_sl1_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl1_1p_cal.tbl', /silent

	forprint, det_sl1_2p, wave_sl1_2p, calflux_sl1_2p, err_sl1_2p, bit_sl1_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl1_2p_cal.tbl', /silent

	forprint, det_sl2_1p, wave_sl2_1p, calflux_sl2_1p, err_sl2_1p, bit_sl2_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl2_1p_cal.tbl', /silent

	forprint, det_sl2_2p, wave_sl2_2p, calflux_sl2_2p, err_sl2_2p, bit_sl2_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl2_2p_cal.tbl', /silent

	forprint, det_sl3_1p, wave_sl3_1p, calflux_sl3_1p, err_sl3_1p, bit_sl3_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl3_1p_cal.tbl', /silent

	forprint, det_sl3_2p, wave_sl3_2p, calflux_sl3_2p, err_sl3_2p, bit_sl3_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_sl3_2p_cal.tbl', /silent

	forprint, det_ll1_1p, wave_ll1_1p, calflux_ll1_1p, err_ll1_1p, bit_ll1_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll1_1p_cal.tbl', /silent

	forprint, det_ll1_2p, wave_ll1_2p, calflux_ll1_2p, err_ll1_2p, bit_ll1_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll1_2p_cal.tbl', /silent

	forprint, det_ll2_1p, wave_ll2_1p, calflux_ll2_1p, err_ll2_1p, bit_ll2_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll2_1p_cal.tbl', /silent

	forprint, det_ll2_2p, wave_ll2_2p, calflux_ll2_2p, err_ll2_2p, bit_ll2_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll2_2p_cal.tbl', /silent

	forprint, det_ll3_1p, wave_ll3_1p, calflux_ll3_1p, err_ll3_1p, bit_ll3_1p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll3_1p_cal.tbl', /silent

	forprint, det_ll3_2p, wave_ll3_2p, calflux_ll3_2p, err_ll3_2p, bit_ll3_2p, format = '(i2,f15.4,e20.4,e20.4,i10)', $
		comment = 'Order   Wavelength [um]      Flux [Jy]         Uncert.        Bit type', $
		textout = writepath_nod+fname+'_ll3_2p_cal.tbl', /silent

endif
print,'Calibrated ',fname,' in SPEC2PUFLUX_LR'

if not keyword_set(nostop) then stop
end

